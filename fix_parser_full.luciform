---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
export class ForStatementNode extends ASTNode {
    constructor(public initializer: ASTNode | undefined, public condition: ASTNode | undefined, public increment: ASTNode | undefined, public body: ASTNode[]) {
        super();
    }
}
=======
export class ForStatementNode extends ASTNode {
    constructor(public initializer: ASTNode | undefined, public condition: ASTNode | undefined, public increment: ASTNode | undefined, public body: ASTNode[]) {
        super();
    }
}

export class ExpressionStatementNode extends ASTNode {
    constructor(public expression: ASTNode) {
        super();
    }
}

export class CallExpressionNode extends ASTNode {
    constructor(public callee: ASTNode, public args: ASTNode[]) {
        super();
    }
}

export class PropertyAccessNode extends ASTNode {
    constructor(public expression: ASTNode, public name: IdentifierNode) {
        super();
    }
}

export class AssignmentExpressionNode extends ASTNode {
    constructor(public left: ASTNode, public operator: Token, public right: ASTNode) {
        super();
    }
}
>>>>>>> REPLACE
---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
export class Parser {
    private readonly tokens: Token[];
    private current: number = 0;

    constructor(tokens: Token[]) {
        this.tokens = tokens.filter(t => t.type !== TokenType.Whitespace && t.type !== TokenType.Comment);
    }
=======
export class Parser {
    private readonly tokens: Token[];
    private current: number = 0;
    public parseErrors: string[] = [];

    constructor(tokens: Token[]) {
        this.tokens = tokens.filter(t => t.type !== TokenType.Whitespace && t.type !== TokenType.Comment);
    }
>>>>>>> REPLACE
---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
    private consume(type: TokenType, message: string): Token;
    private consume(type: TokenType, text: string, message: string): Token;
    private consume(type: TokenType, textOrMessage: string, message?: string): Token {
        const text = message ? textOrMessage : undefined;
        const msg = message || textOrMessage;
        if (this.check(type, text)) {
            return this.advance();
        }
        throw new Error(`${msg} at line ${this.peek().line}, column ${this.peek().column}`);
    }
=======
    private consume(type: TokenType, message: string): Token;
    private consume(type: TokenType, text: string, message: string): Token;
    private consume(type: TokenType, textOrMessage: string, message?: string): Token {
        const text = message ? textOrMessage : undefined;
        const msg = message || textOrMessage;
        if (this.check(type, text)) {
            return this.advance();
        }
        this.parseErrors.push(`${msg} at line ${this.peek().line}, column ${this.peek().column}`);
        return this.advance(); // Attempt to advance past the problematic token
    }
>>>>>>> REPLACE
