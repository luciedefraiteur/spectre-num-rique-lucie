---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
export class AssignmentExpressionNode extends ASTNode {
    constructor(public left: ASTNode, public operator: Token, public right: ASTNode) {
        super();
    }
}

export class ImportDeclarationNode extends ASTNode {
    constructor(public imports: (IdentifierNode | { alias: IdentifierNode, name: IdentifierNode })[], public moduleSpecifier: StringLiteralNode) {
        super();
    }
}
=======
export class AssignmentExpressionNode extends ASTNode {
    constructor(public left: ASTNode, public operator: Token, public right: ASTNode) {
        super();
    }
}
>>>>>>> REPLACE
---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
    private declaration(): ASTNode {
        if (this.match(TokenType.Keyword, 'const', 'let', 'var')) {
            return this.variableDeclaration();
        }
        if (this.match(TokenType.Keyword, 'function')) {
            return this.functionDeclaration();
        }
        if (this.match(TokenType.Keyword, 'import')) {
            return this.importDeclaration();
        }
        // Add other declaration types (class, interface, etc.)
        return this.statement();
    }

    private importDeclaration(): ASTNode {
        let imports: (IdentifierNode | { alias: IdentifierNode, name: IdentifierNode })[] = [];
        if (this.match(TokenType.Punctuation, '{')) {
            // Named imports
            do {
                const name = this.consume(TokenType.Identifier, 'Expect identifier in import.');
                let alias: IdentifierNode | undefined;
                if (this.match(TokenType.Keyword, 'as')) {
                    alias = new IdentifierNode(this.consume(TokenType.Identifier, 'Expect alias after 'as'.').text);
                }
                imports.push(alias ? { name: new IdentifierNode(name.text), alias } : new IdentifierNode(name.text));
            } while (this.match(TokenType.Punctuation, ','));
            this.consume(TokenType.Punctuation, '}', 'Expect '}' after import specifiers.');
        } else if (this.match(TokenType.Identifier)) {
            // Default import
            imports.push(new IdentifierNode(this.previous().text));
        }

        this.consume(TokenType.Keyword, 'from', 'Expect 'from' after import specifiers.');
        const moduleSpecifier = new StringLiteralNode(this.consume(TokenType.StringLiteral, 'Expect module specifier.').text);
        this.consume(TokenType.Punctuation, ';', 'Expect ';' after import declaration.');

        return new ImportDeclarationNode(imports, moduleSpecifier);
    }
=======
    private declaration(): ASTNode {
        if (this.match(TokenType.Keyword, 'const', 'let', 'var')) {
            return this.variableDeclaration();
        }
        if (this.match(TokenType.Keyword, 'function')) {
            return this.functionDeclaration();
        }
        // Add other declaration types (class, interface, etc.)
        return this.statement();
    }
>>>>>>> REPLACE
