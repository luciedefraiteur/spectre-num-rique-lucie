---
§F: core/batch_editor.ts
<<<<<<< INSERT:line:1
async function logErrorToFile(message: string) {
    try {
        await fs.appendFile('batch_editor_errors.log', message + '\n', 'utf-8');
    } catch (fileError) {
        // Fallback to console.error if file logging fails
        console.error(`Error writing to batch_editor_errors.log: ${fileError}`);
    }
}
>>>>>>> INSERT
---
§F: core/batch_editor.ts
<<<<<<< SEARCH
        case 'create_file':
            if (op.type !== 'create_file') return; // Type guard
            const dir = path.dirname(op.filePath);
            console.log(`Attempting to create directory: ${dir}`);
            await fs.mkdir(dir, {recursive: true});
            console.log(`Attempting to write file: ${op.filePath}`);
            await fs.writeFile(op.filePath, op.content, 'utf-8');
            console.log(`Successfully created ${ op.filePath }`);
            break;
>>>>>>> SEARCH
======= REPLACE
        case 'create_file':
            try {
                if (op.type !== 'create_file') return; // Type guard
                const dir = path.dirname(op.filePath);
                console.log(`Attempting to create directory: ${dir}`);
                await fs.mkdir(dir, {recursive: true});
                console.log(`Attempting to write file: ${op.filePath}`);
                await fs.writeFile(op.filePath, op.content, 'utf-8');
                console.log(`Successfully created ${ op.filePath }`);
            } catch (error) {
                await logErrorToFile(`Error in create_file operation: ${JSON.stringify(op)} - ${error}`);
                throw error;
            }
            break;
>>>>>>> REPLACE
---
§F: core/batch_editor.ts
<<<<<<< SEARCH
        case 'search_and_replace':
            if (op.type !== 'search_and_replace') return; // Type guard
            originalContent = await fs.readFile(op.filePath, 'utf-8');
            // Normalize line endings for consistent replacement
            const normalizedOriginalContent = originalContent.replace(/\r\n/g, '\n');
            const normalizedSearch = op.search.replace(/\r\n/g, '\n');
            const normalizedReplace = op.replace.replace(/\r\n/g, '\n');

            const startIndex = normalizedOriginalContent.indexOf(normalizedSearch);

            if (startIndex === -1) {
                throw new Error(`Search content not found in ${op.filePath}`);
            }

            const endIndex = startIndex + normalizedSearch.length;
            const newContent = normalizedOriginalContent.substring(0, startIndex) + normalizedReplace + normalizedOriginalContent.substring(endIndex);

            await fs.writeFile(op.filePath, newContent, 'utf-8');
            console.log(`Successfully edited ${op.filePath}`);
            break;
>>>>>>> SEARCH
======= REPLACE
        case 'search_and_replace':
            try {
                if (op.type !== 'search_and_replace') return; // Type guard
                originalContent = await fs.readFile(op.filePath, 'utf-8');
                // Normalize line endings for consistent replacement
                const normalizedOriginalContent = originalContent.replace(/\r\n/g, '\n');
                const normalizedSearch = op.search.replace(/\r\n/g, '\n');
                const normalizedReplace = op.replace.replace(/\r\n/g, '\n');

                const startIndex = normalizedOriginalContent.indexOf(normalizedSearch);

                if (startIndex === -1) {
                    throw new Error(`Search content not found in ${op.filePath}`);
                }

                const endIndex = startIndex + normalizedSearch.length;
                const newContent = normalizedOriginalContent.substring(0, startIndex) + normalizedReplace + normalizedOriginalContent.substring(endIndex);

                await fs.writeFile(op.filePath, newContent, 'utf-8');
                console.log(`Successfully edited ${op.filePath}`);
            } catch (error) {
                await logErrorToFile(`Error in search_and_replace operation: ${JSON.stringify(op)} - ${error}`);
                throw error;
            }
            break;
>>>>>>> REPLACE
---
§F: core/batch_editor.ts
<<<<<<< SEARCH
        case 'insert':
            if (op.type !== 'insert') return; // Type guard
            originalContent = await fs.readFile(op.filePath, 'utf-8');
            const linesInsert = originalContent.replace(/\r\n/g, '\n').split('\n');
            const newContentInsert = op.newContent.replace(/\r\n/g, '\n');

            const newLinesInsert = [
                ...linesInsert.slice(0, op.lineNumber - 1),
                newContentInsert,
                ...linesInsert.slice(op.lineNumber - 1)
            ];
            await fs.writeFile(op.filePath, newLinesInsert.join('\n'), 'utf-8');
            console.log(`Successfully edited ${ op.filePath }`);
            break;
>>>>>>> SEARCH
======= REPLACE
        case 'insert':
            try {
                if (op.type !== 'insert') return; // Type guard
                originalContent = await fs.readFile(op.filePath, 'utf-8');
                const linesInsert = originalContent.replace(/\r\n/g, '\n').split('\n');
                const newContentInsert = op.newContent.replace(/\r\n/g, '\n');

                const newLinesInsert = [
                    ...linesInsert.slice(0, op.lineNumber - 1),
                    newContentInsert,
                    ...linesInsert.slice(op.lineNumber - 1)
                ];
                await fs.writeFile(op.filePath, newLinesInsert.join('\n'), 'utf-8');
                console.log(`Successfully edited ${ op.filePath }`);
            } catch (error) {
                await logErrorToFile(`Error in insert operation: ${JSON.stringify(op)} - ${error}`);
                throw error;
            }
            break;
>>>>>>> REPLACE
---
§F: core/batch_editor.ts
<<<<<<< SEARCH
        case 'delete':
            if (op.type !== 'delete') return; // Type guard
            originalContent = await fs.readFile(op.filePath, 'utf-8');
            const linesDelete = originalContent.replace(/\r\n/g, '\n').split('\n');
            const newLinesDelete = [
                ...linesDelete.slice(0, op.startLine - 1),
                ...linesDelete.slice(op.endLine)
            ];
            await fs.writeFile(op.filePath, newLinesDelete.join('\n'), 'utf-8');
            console.log(`Successfully edited ${ op.filePath }`);
            break;
>>>>>>> SEARCH
======= REPLACE
        case 'delete':
            try {
                if (op.type !== 'delete') return; // Type guard
                originalContent = await fs.readFile(op.filePath, 'utf-8');
                const linesDelete = originalContent.replace(/\r\n/g, '\n').split('\n');
                const newLinesDelete = [
                    ...linesDelete.slice(0, op.startLine - 1),
                    ...linesDelete.slice(op.endLine)
                ];
                await fs.writeFile(op.filePath, newLinesDelete.join('\n'), 'utf-8');
                console.log(`Successfully edited ${ op.filePath }`);
            } catch (error) {
                await logErrorToFile(`Error in delete operation: ${JSON.stringify(op)} - ${error}`);
                throw error;
            }
            break;
>>>>>>> REPLACE
---
§F: core/batch_editor.ts
<<<<<<< SEARCH
        case 'append':
            if (op.type !== 'append') return; // Type guard
            const newContentAppend = op.newContent.replace(/\r\n/g, '\n');
            await fs.appendFile(op.filePath, newContentAppend, 'utf-8');
            console.log(`Successfully edited ${ op.filePath }`);
            break;
>>>>>>> SEARCH
======= REPLACE
        case 'append':
            try {
                if (op.type !== 'append') return; // Type guard
                const newContentAppend = op.newContent.replace(/\r\n/g, '\n');
                await fs.appendFile(op.filePath, newContentAppend, 'utf-8');
                console.log(`Successfully edited ${ op.filePath }`);
            } catch (error) {
                await logErrorToFile(`Error in append operation: ${JSON.stringify(op)} - ${error}`);
                throw error;
            }
            break;
>>>>>>> REPLACE
---
§F: core/batch_editor.ts
<<<<<<< SEARCH
        case 'shell_command':
            if (op.type !== 'shell_command') return; // Type guard
            const isWindows = process.platform === 'win32';
            const command = isWindows ? op.command.replace(/rm /g, 'del ') : op.command;
            await executeShellCommand(command);
            break;
>>>>>>> SEARCH
======= REPLACE
        case 'shell_command':
            try {
                if (op.type !== 'shell_command') return; // Type guard
                const isWindows = process.platform === 'win32';
                const command = isWindows ? op.command.replace(/rm /g, 'del ') : op.command;
                await executeShellCommand(command);
            } catch (error) {
                await logErrorToFile(`Error in shell_command operation: ${JSON.stringify(op)} - ${error}`);
                throw error;
            }
            break;
>>>>>>> REPLACE
