---file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts<<<<<<< SEARCHexport class ForStatementNode extends ASTNode {    constructor(public initializer: ASTNode | undefined, public condition: ASTNode | undefined, public increment: ASTNode | undefined, public body: ASTNode[]) {        super();    }}=======export class ForStatementNode extends ASTNode {    constructor(public initializer: ASTNode | undefined, public condition: ASTNode | undefined, public increment: ASTNode | undefined, public body: ASTNode[]) {        super();    }}export class ExpressionStatementNode extends ASTNode {    constructor(public expression: ASTNode) {        super();    }}export class CallExpressionNode extends ASTNode {    constructor(public callee: ASTNode, public args: ASTNode[]) {        super();    }}>>>>>>> REPLACE---file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts<<<<<<< SEARCH    private statement(): ASTNode {        if (this.match(TokenType.Keyword, 'if')) {            return this.ifStatement();        }        if (this.match(TokenType.Keyword, 'return')) {            return this.returnStatement();        }        if (this.match(TokenType.Keyword, 'while')) {            return this.whileStatement();        }        if (this.match(TokenType.Keyword, 'for')) {            return this.forStatement();        }        // For now, just consume expressions        const expr = this.expression();        this.consume(TokenType.Punctuation, ';', 'Expect ";" after expression.');        return expr;=======    private statement(): ASTNode {        if (this.match(TokenType.Keyword, 'if')) {            return this.ifStatement();        }        if (this.match(TokenType.Keyword, 'return')) {            return this.returnStatement();        }        if (this.match(TokenType.Keyword, 'while')) {            return this.whileStatement();        }        if (this.match(TokenType.Keyword, 'for')) {            return this.forStatement();        }        return this.expressionStatement();    }    private expressionStatement(): ASTNode {        const expr = this.expression();        this.consume(TokenType.Punctuation, ';', 'Expect ";" after expression.');        return new ExpressionStatementNode(expr);    }>>>>>>> REPLACE---file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts<<<<<<< SEARCH        throw new Error(`Unexpected token: ${this.peek().text}`);    }=======        throw new Error(`Unexpected token: ${this.peek().text}`);    }    private callExpression(callee: ASTNode): ASTNode {        const args: ASTNode[] = [];        this.consume(TokenType.Punctuation, '(', 'Expect "(" after function name.');        if (!this.check(TokenType.Punctuation, ')')) {            do {                args.push(this.expression());            } while (this.match(TokenType.Punctuation, ','));        }        this.consume(TokenType.Punctuation, ')', 'Expect ")" after arguments.');        return new CallExpressionNode(callee, args);    }>>>>>>> REPLACE---file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts<<<<<<< SEARCH        let expr = this.primary();        while (this.match(TokenType.Operator)) {            const operator = this.previous();            const right = this.primary();            expr = new BinaryExpressionNode(expr, operator, right);        }        return expr;=======        let expr = this.primary();        while (true) {            if (this.match(TokenType.Punctuation, '(')) {                expr = this.callExpression(expr);            } else if (this.match(TokenType.Operator)) {                const operator = this.previous();                const right = this.primary();                expr = new BinaryExpressionNode(expr, operator, right);            } else {                break;            }        }        return expr;>>>>>>> REPLACE