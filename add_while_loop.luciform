---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
export class ReturnStatementNode extends ASTNode {
    constructor(public argument?: ASTNode) {
        super();
    }
}
=======
export class ReturnStatementNode extends ASTNode {
    constructor(public argument?: ASTNode) {
        super();
    }
}

export class WhileStatementNode extends ASTNode {
    constructor(public condition: ASTNode, public body: ASTNode[]) {
        super();
    }
}
>>>>>>> REPLACE
---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
    private returnStatement(): ASTNode {
        let value;
        if (!this.check(TokenType.Punctuation, ';')) {
            value = this.expression();
        }
        this.consume(TokenType.Punctuation, ';', 'Expect ';' after return value.');
        return new ReturnStatementNode(value);
    }
=======
    private returnStatement(): ASTNode {
        let value;
        if (!this.check(TokenType.Punctuation, ';')) {
            value = this.expression();
        }
        this.consume(TokenType.Punctuation, ';', 'Expect ';' after return value.');
        return new ReturnStatementNode(value);
    }

    private whileStatement(): ASTNode {
        this.consume(TokenType.Punctuation, '(', 'Expect '(' after 'while'.');
        const condition = this.expression();
        this.consume(TokenType.Punctuation, ')', 'Expect ')' after while condition.');
        this.consume(TokenType.Punctuation, '{', 'Expect '{' before while body.');
        const body = this.block();
        return new WhileStatementNode(condition, body);
    }
>>>>>>> REPLACE
---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
        if (this.match(TokenType.Keyword, 'return')) {
            return this.returnStatement();
        }
        // For now, just consume expressions
        const expr = this.expression();
        this.consume(TokenType.Punctuation, ';', 'Expect ';' after expression.');
        return expr;
=======
        if (this.match(TokenType.Keyword, 'return')) {
            return this.returnStatement();
        }
        if (this.match(TokenType.Keyword, 'while')) {
            return this.whileStatement();
        }
        // For now, just consume expressions
        const expr = this.expression();
        this.consume(TokenType.Punctuation, ';', 'Expect ';' after expression.');
        return expr;
>>>>>>> REPLACE
