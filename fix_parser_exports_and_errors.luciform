---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
export class ForStatementNode extends ASTNode {
    constructor(public initializer: ASTNode | undefined, public condition: ASTNode | undefined, public increment: ASTNode | undefined, public body: ASTNode[]) {
        super();
    }
}
=======
export class ForStatementNode extends ASTNode {
    constructor(public initializer: ASTNode | undefined, public condition: ASTNode | undefined, public increment: ASTNode | undefined, public body: ASTNode[]) {
        super();
    }
}

export class ExpressionStatementNode extends ASTNode {
    constructor(public expression: ASTNode) {
        super();
    }
}

export class CallExpressionNode extends ASTNode {
    constructor(public callee: ASTNode, public args: ASTNode[]) {
        super();
    }
}

export class PropertyAccessNode extends ASTNode {
    constructor(public expression: ASTNode, public name: IdentifierNode) {
        super();
    }
}

export class AssignmentExpressionNode extends ASTNode {
    constructor(public left: ASTNode, public operator: Token, public right: ASTNode) {
        super();
    }
}
>>>>>>> REPLACE
---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
export class Parser {
    private readonly tokens: Token[];
    private current: number = 0;
    public parseErrors: string[] = [];

    constructor(tokens: Token[]) {
        this.tokens = tokens.filter(t => t.type !== TokenType.Whitespace && t.type !== TokenType.Comment);
    }
=======
export class Parser {
    private readonly tokens: Token[];
    private current: number = 0;
    public parseErrors: string[] = [];

    constructor(tokens: Token[]) {
        this.tokens = tokens.filter(t => t.type !== TokenType.Whitespace && t.type !== TokenType.Comment);
    }
>>>>>>> REPLACE
