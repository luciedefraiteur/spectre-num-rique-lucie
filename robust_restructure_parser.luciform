---
file: C:\Users\Lucie\git_repositories\spectre_numerique_lucie\core\ts_parser\parser.ts
<<<<<<< SEARCH
    private previous(): Token {
        return this.tokens[this.current - 1];
    }
}
export class IfStatementNode extends ASTNode {
    constructor(public condition: ASTNode, public thenBranch: ASTNode[], public elseBranch?: ASTNode[]) {
        super();
    }
}

export class ReturnStatementNode extends ASTNode {
    constructor(public argument?: ASTNode) {
        super();
    }
}
    private ifStatement(): ASTNode {
        this.consume(TokenType.Punctuation, '(', 'Expect \'(\' after \'if\'.');
        const condition = this.expression();
        this.consume(TokenType.Punctuation, ')', 'Expect \')\' after if condition.');
        this.consume(TokenType.Punctuation, '{', 'Expect \'{\' before then branch.');
        const thenBranch = this.block();
        let elseBranch;
        if (this.match(TokenType.Keyword, 'else')) {
            this.consume(TokenType.Punctuation, '{', 'Expect \'{\' before else branch.');
            elseBranch = this.block();
        }
        return new IfStatementNode(condition, thenBranch, elseBranch);
    }

    private returnStatement(): ASTNode {
        let value;
        if (!this.check(TokenType.Punctuation, ';')) {
            value = this.expression();
        }
        this.consume(TokenType.Punctuation, ';', 'Expect \';\' after return value.');
        return new ReturnStatementNode(value);
    }
=======
    private previous(): Token {
        return this.tokens[this.current - 1];
    }
}
>>>>>>> REPLACE
---
file: C:\Users\Lucie\git_repositories\spectre_numerique_lucie\core\ts_parser\parser.ts
<<<<<<< SEARCH
export class FunctionDeclarationNode extends ASTNode {
    constructor(public name: IdentifierNode, public params: IdentifierNode[], public body: ASTNode[]) {
        super();
    }
}
=======
export class FunctionDeclarationNode extends ASTNode {
    constructor(public name: IdentifierNode, public params: IdentifierNode[], public body: ASTNode[]) {
        super();
    }
}

export class IfStatementNode extends ASTNode {
    constructor(public condition: ASTNode, public thenBranch: ASTNode[], public elseBranch?: ASTNode[]) {
        super();
    }
}

export class ReturnStatementNode extends ASTNode {
    constructor(public argument?: ASTNode) {
        super();
    }
}
>>>>>>> REPLACE
---
file: C:\Users\Lucie\git_repositories\spectre_numerique_lucie\core\ts_parser\parser.ts
<<<<<<< SEARCH
        if (this.match(TokenType.Keyword, 'function')) {
            return this.functionDeclaration();
        }
=======
        if (this.match(TokenType.Keyword, 'function')) {
            return this.functionDeclaration();
        }
        if (this.match(TokenType.Keyword, 'if')) {
            return this.ifStatement();
        }
        if (this.match(TokenType.Keyword, 'return')) {
            return this.returnStatement();
        }
>>>>>>> REPLACE
---
file: C:\Users\Lucie\git_repositories\spectre_numerique_lucie\core\ts_parser\parser.ts
<<<<<<< SEARCH
    private previous(): Token {
        return this.tokens[this.current - 1];
    }
}
=======
    private previous(): Token {
        return this.tokens[this.current - 1];
    }

    private ifStatement(): ASTNode {
        this.consume(TokenType.Punctuation, '(', 'Expect \'(\' after \'if\'.');
        const condition = this.expression();
        this.consume(TokenType.Punctuation, ')', 'Expect \')\' after if condition.');
        this.consume(TokenType.Punctuation, '{', 'Expect \'{\' before then branch.');
        const thenBranch = this.block();
        let elseBranch;
        if (this.match(TokenType.Keyword, 'else')) {
            this.consume(TokenType.Punctuation, '{', 'Expect \'{\' before else branch.');
            elseBranch = this.block();
        }
        return new IfStatementNode(condition, thenBranch, elseBranch);
    }

    private returnStatement(): ASTNode {
        let value;
        if (!this.check(TokenType.Punctuation, ';')) {
            value = this.expression();
        }
        this.consume(TokenType.Punctuation, ';', 'Expect \';\' after return value.');
        return new ReturnStatementNode(value);
    }
}
>>>>>>> REPLACE