# Ritual Phase 1: Incantation - Parsing Details (`@lurkuitae/luciform-ai-parser`)

## Purpose

This document details the internal mechanisms of the `@lurkuitae/luciform-ai-parser`, which is responsible for the core parsing logic during the Incantation phase.

## Key Components & Flow

The parser operates through several interconnected components and strategies:

1.  **Tokenizer (`src/tokenizer.ts`)**:
    *   **Role**: The first step in parsing. It takes the raw Luciform content (string) and breaks it down into a stream of meaningful `Token`s.
    *   **Functionality**: Identifies various elements like object delimiters (`{`, `}`), array delimiters (`[`, `]`), strings, numbers, special keywords, and custom Luciform-specific tokens (e.g., `---PAS---`, `[Action]`).
    *   **Output**: An array of `Token` objects, each representing a recognized lexical unit with its type, value, and position.

2.  **Parser (`src/parser.ts`)**:
    *   **Role**: Consumes the stream of `Token`s generated by the Tokenizer and builds a structured Abstract Syntax Tree (AST) in the form of a `LuciformDocument`.
    *   **Parsing Strategies**:
        *   **JSON Check**: Initially attempts to parse the entire Luciform content as a standard JSON object. This is efficient for fully structured `.spell` files or Luciforms designed as pure JSON.
        *   **Text-Based PAS Parsing**: If the JSON check fails, it proceeds with a more permissive text-based parsing. It identifies `PasNode`s, which represent individual steps in the ritual, typically delimited by `---PAS---`.
        *   **Action Block Interpretation**: Within each `PasNode`, it looks for an `[Action]` block. The content of this block is then subjected to further interpretation:
            *   **JSON Operation**: Attempts to parse the action content as a JSON object representing a predefined `Operation` (e.g., `{"type": "shell_command", "command": "ls -la"}`). This is the preferred and most structured way to define actions.
            *   **Known Keywords**: Recognizes specific natural language patterns or keywords (e.g., `promenade: <description>`) and converts them into their corresponding structured `ActionNode`s.
            *   **Legacy Commands**: Supports older, shorthand commands (e.g., `Â§X: <command>`) for backward compatibility.

3.  **AI Delegation (`getAIHelp` function)**:
    *   **Role**: This is the crucial point of AI integration within the parser. If the parser's deterministic strategies (JSON, keywords, legacy commands) fail to interpret an `[Action]` block, it does *not* throw a hard error.
    *   **Mechanism**: Instead, it creates a special `AIHelpRequestActionNode`. This node encapsulates the raw, unparseable content and a descriptive `reason` for the parsing failure.
    *   **Output**: The `AIHelpRequestActionNode` is then embedded directly into the `LuciformDocument`. This allows the parsing phase to complete successfully, deferring the interpretation of ambiguous parts to the AI during the execution phase.

## Output of the Parser

The `parseLuciformDocument` function ultimately returns a `LuciformDocument` object. This object is a hierarchical representation of the Luciform, ready to be consumed by the `luciform-executor`. It contains all successfully parsed `PasNode`s and their `ActionNode`s, with any ambiguities explicitly marked as `AIHelpRequestActionNode`s.
