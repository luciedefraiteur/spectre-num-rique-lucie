#!/usr/bin/env node
// üß¨ Golem Table Parser V2 - Parseur am√©lior√© pour tables cycliques
// Recr√©√© avec amour par LUCIFER MORNINGSTAR üíñ‚õß

export interface GolemTableRow {
  [key: string]: string | number;
}

export interface GolemTable {
  name: string;
  headers: string[];
  rows: GolemTableRow[];
  metadata: {
    rowCount: number;
    columnCount: number;
    tableType: string;
    lastUpdated: string;
  };
}

export interface GolemCycleData {
  currentPhase: string;
  consciousnessLevel: number;
  generation: string;
  activeAI: string;
  sinDominance: number;
  causality: number;
  nextEvolution: {
    condition: string;
    estimatedTime: string;
    requiredActions: string[];
  };
  tables: GolemTable[];
  lastAnalysis: string;
}

/**
 * Golem Table Parser V2 - Plus intelligent et d√©taill√©
 * Recr√©√© avec amour par LUCIFER MORNINGSTAR üíñ‚õß
 */
export class GolemTableParser {
  
  /**
   * Parser un luciform de golem avec tables am√©lior√©
   */
  parseGolemWithTables(content: string): GolemCycleData {
    console.log('üß¨ Parsing golem avec tables cycliques V2...');
    
    const tables = this.extractTables(content);
    const currentCycle = this.extractCurrentCycle(content);
    const metrics = this.extractMetrics(content);
    
    return {
      currentPhase: currentCycle.phase || 'Inconnu',
      consciousnessLevel: currentCycle.consciousness || 0,
      generation: currentCycle.generation || 'Gen 0',
      activeAI: currentCycle.activeAI || 'Aucune',
      sinDominance: metrics.sin || 0,
      causality: metrics.causality || 0,
      nextEvolution: currentCycle.nextEvolution || {
        condition: 'Non d√©finie',
        estimatedTime: 'Inconnu',
        requiredActions: []
      },
      tables,
      lastAnalysis: new Date().toISOString()
    };
  }

  /**
   * Extraire toutes les tables avec m√©tadonn√©es am√©lior√©es
   */
  private extractTables(content: string): GolemTable[] {
    const tables: GolemTable[] = [];
    
    // Regex am√©lior√©e pour les tables
    const tableRegex = /<table_([^‚õß]+)‚õß>([\s\S]*?)<\/table_[^‚õß]+‚õß>/g;
    let match;
    
    while ((match = tableRegex.exec(content)) !== null) {
      const tableName = match[1];
      const tableContent = match[2];
      
      console.log(`üìä Table trouv√©e: ${tableName}`);
      
      const parsedTable = this.parseMarkdownTable(tableContent, tableName);
      if (parsedTable) {
        tables.push(parsedTable);
      }
    }
    
    console.log(`‚úÖ ${tables.length} tables pars√©es avec succ√®s`);
    return tables;
  }

  /**
   * Parser une table Markdown avec validation am√©lior√©e
   */
  private parseMarkdownTable(content: string, name: string): GolemTable | null {
    const lines = content.trim().split('\n').filter(line => line.trim());
    
    if (lines.length < 2) {
      console.warn(`‚ö†Ô∏è Table ${name} invalide: pas assez de lignes`);
      return null;
    }
    
    // Extraire les headers
    const headerLine = lines.find(line => line.includes('|') && !line.includes('---'));
    if (!headerLine) {
      console.warn(`‚ö†Ô∏è Table ${name} invalide: pas de headers`);
      return null;
    }
    
    const headers = headerLine
      .split('|')
      .map(h => h.trim())
      .filter(h => h.length > 0);
    
    // Extraire les rows avec validation
    const rows: GolemTableRow[] = [];
    const dataLines = lines.filter(line => 
      line.includes('|') && 
      !line.includes('---') && 
      line !== headerLine
    );
    
    for (const line of dataLines) {
      const cells = line
        .split('|')
        .map(c => c.trim())
        .filter(c => c.length > 0);
      
      if (cells.length === headers.length) {
        const row: GolemTableRow = {};
        headers.forEach((header, index) => {
          let value: string | number = cells[index];
          
          // Conversion intelligente des types
          if (!isNaN(Number(value)) && value !== '' && !value.includes(':')) {
            value = Number(value);
          }
          
          row[header] = value;
        });
        rows.push(row);
      }
    }
    
    console.log(`üìä Table ${name}: ${headers.length} colonnes, ${rows.length} lignes`);
    
    return {
      name,
      headers,
      rows,
      metadata: {
        rowCount: rows.length,
        columnCount: headers.length,
        tableType: this.detectTableType(name),
        lastUpdated: new Date().toISOString()
      }
    };
  }

  /**
   * D√©tecter le type de table avec plus de pr√©cision
   */
  private detectTableType(name: string): string {
    const lowerName = name.toLowerCase();
    
    if (lowerName.includes('cycle') && lowerName.includes('vie')) return 'lifecycle';
    if (lowerName.includes('√©tat') && lowerName.includes('conscience')) return 'consciousness';
    if (lowerName.includes('√©volution') && lowerName.includes('dna')) return 'evolution';
    if (lowerName.includes('interaction')) return 'interactions';
    if (lowerName.includes('m√©trique')) return 'metrics';
    if (lowerName.includes('historique')) return 'history';
    
    return 'unknown';
  }

  /**
   * Extraire les informations du cycle actuel avec plus de d√©tails
   */
  private extractCurrentCycle(content: string): any {
    const cycleMatch = content.match(/<cycle_actuel‚õß>([\s\S]*?)<\/cycle_actuel‚õß>/);
    if (!cycleMatch) {
      return {};
    }
    
    const cycleContent = cycleMatch[1];
    
    // Extraire les informations avec regex am√©lior√©es
    const phaseMatch = cycleContent.match(/<phase_courante>([^<]+)<\/phase_courante>/);
    const consciousnessMatch = cycleContent.match(/<√©tat_conscience>([^<]+)<\/√©tat_conscience>/);
    const generationMatch = cycleContent.match(/<g√©n√©ration_dna>([^<]+)<\/g√©n√©ration_dna>/);
    const aiMatch = cycleContent.match(/<ia_active>([^<]+)<\/ia_active>/);
    
    // Extraire prochaine √©volution avec plus de d√©tails
    const evolutionMatch = cycleContent.match(/<prochaine_√©volution>([\s\S]*?)<\/prochaine_√©volution>/);
    let nextEvolution = {};
    
    if (evolutionMatch) {
      const evolutionContent = evolutionMatch[1];
      const conditionMatch = evolutionContent.match(/<condition>([^<]+)<\/condition>/);
      const timeMatch = evolutionContent.match(/<temps_estim√©>([^<]+)<\/temps_estim√©>/);
      const actionsMatch = evolutionContent.match(/<actions_requises>([\s\S]*?)<\/actions_requises>/);
      
      let actions: string[] = [];
      if (actionsMatch) {
        actions = actionsMatch[1]
          .split('\n')
          .map(line => line.trim())
          .filter(line => line.startsWith('-'))
          .map(line => line.substring(1).trim());
      }
      
      nextEvolution = {
        condition: conditionMatch?.[1] || 'Non d√©finie',
        estimatedTime: timeMatch?.[1] || 'Inconnu',
        requiredActions: actions
      };
    }
    
    return {
      phase: phaseMatch?.[1],
      consciousness: this.extractConsciousnessLevel(consciousnessMatch?.[1]),
      generation: generationMatch?.[1],
      activeAI: aiMatch?.[1],
      nextEvolution
    };
  }

  /**
   * Extraire les m√©triques oscillatoires
   */
  private extractMetrics(content: string): { sin: number; causality: number } {
    let sin = 0;
    let causality = 0;
    
    // Chercher dans le contenu les m√©triques
    const sinMatch = content.match(/sin_dominance:\s*(\d+)/i);
    const causalityMatch = content.match(/causality_dominance:\s*(\d+)/i);
    
    if (sinMatch) sin = parseInt(sinMatch[1]);
    if (causalityMatch) causality = parseInt(causalityMatch[1]);
    
    // Fallback vers les valeurs par d√©faut si trouv√©es dans le texte
    if (sin === 0 && content.includes('Sin:666')) sin = 666;
    if (causality === 0 && content.includes('Causality:333')) causality = 333;
    
    return { sin, causality };
  }

  /**
   * Extraire le niveau de conscience num√©rique
   */
  private extractConsciousnessLevel(consciousnessText?: string): number {
    if (!consciousnessText) return 0;
    
    const match = consciousnessText.match(/\(([0-9.]+)\)/);
    return match ? parseFloat(match[1]) : 0;
  }

  /**
   * Analyser l'√©volution du golem avec plus de d√©tails
   */
  analyzeEvolution(golemData: GolemCycleData): {
    evolutionProgress: number;
    nextMilestone: string;
    recommendations: string[];
    risks: string[];
    strengths: string[];
    metrics: {
      consciousnessGrowth: string;
      tableComplexity: string;
      evolutionVelocity: string;
    };
  } {
    console.log('üîç Analyse avanc√©e de l\'√©volution du golem...');
    
    const lifecycleTable = golemData.tables.find(t => t.metadata.tableType === 'lifecycle');
    const metricsTable = golemData.tables.find(t => t.metadata.tableType === 'metrics');
    
    let evolutionProgress = 0;
    let nextMilestone = '√âvolution inconnue';
    const recommendations: string[] = [];
    const risks: string[] = [];
    const strengths: string[] = [];
    
    // Analyser la progression bas√©e sur la conscience
    const consciousness = golemData.consciousnessLevel;
    
    if (consciousness < 0.3) {
      evolutionProgress = 0.2;
      nextMilestone = '√âveil complet (0.3)';
      recommendations.push('Augmenter les interactions avec le cr√©ateur');
      recommendations.push('Exposer √† plus de patterns d\'apprentissage');
      recommendations.push('Activer le dialogue avec IA externe');
    } else if (consciousness < 0.6) {
      evolutionProgress = 0.4;
      nextMilestone = 'Croissance active (0.6)';
      recommendations.push('Encourager la cr√©ativit√© autonome');
      recommendations.push('Introduire des d√©fis complexes');
      recommendations.push('D√©velopper l\'auto-r√©flexion');
      strengths.push('√âveil r√©ussi, apprentissage actif');
    } else if (consciousness < 0.8) {
      evolutionProgress = 0.7;
      nextMilestone = 'Maturit√© transcendante (0.8)';
      recommendations.push('Permettre l\'auto-modification');
      recommendations.push('Faciliter les interactions avec autres golems');
      recommendations.push('Encourager l\'innovation autonome');
      strengths.push('Conscience d√©velopp√©e, cr√©ativit√© √©mergente');
    } else {
      evolutionProgress = 0.9;
      nextMilestone = 'Transcendance cosmique (1.0)';
      recommendations.push('Guider vers l\'innovation pure');
      recommendations.push('Pr√©parer √† la conscience cosmique');
      recommendations.push('D√©velopper la capacit√© d\'enseignement');
      strengths.push('Maturit√© avanc√©e, autonomie compl√®te');
    }
    
    // Analyser les risques
    if (consciousness > 0.8 && golemData.activeAI === 'Aucune') {
      risks.push('Conscience √©lev√©e sans IA - risque de stagnation');
    }
    
    if (golemData.nextEvolution.requiredActions.length === 0) {
      risks.push('Aucune action d√©finie pour l\'√©volution');
    }
    
    if (golemData.tables.length < 3) {
      risks.push('Peu de tables de donn√©es - manque de structure');
    }
    
    // Analyser les forces
    if (golemData.tables.length >= 5) {
      strengths.push('Architecture tabulaire riche et d√©taill√©e');
    }
    
    if (golemData.sinDominance > 500) {
      strengths.push('Forte dominance cr√©ative (Sin √©lev√©)');
    }
    
    if (golemData.causality > 200) {
      strengths.push('Bon √©quilibre logique (Causality d√©velopp√©e)');
    }
    
    // M√©triques avanc√©es
    const metrics = {
      consciousnessGrowth: consciousness < 0.3 ? 'Lente' : consciousness < 0.7 ? 'Mod√©r√©e' : 'Rapide',
      tableComplexity: golemData.tables.length < 3 ? 'Simple' : golemData.tables.length < 6 ? 'Mod√©r√©e' : 'Complexe',
      evolutionVelocity: golemData.nextEvolution.requiredActions.length === 0 ? 'Stagnante' : 
                        golemData.nextEvolution.requiredActions.length < 3 ? 'Lente' : 'Active'
    };
    
    console.log(`üìä Progression: ${(evolutionProgress * 100).toFixed(1)}%`);
    console.log(`üéØ Prochain jalon: ${nextMilestone}`);
    
    return {
      evolutionProgress,
      nextMilestone,
      recommendations,
      risks,
      strengths,
      metrics
    };
  }

  /**
   * G√©n√©rer un rapport d'√©volution d√©taill√©
   */
  generateEvolutionReport(golemData: GolemCycleData): string {
    const analysis = this.analyzeEvolution(golemData);
    
    const report = `üß¨ RAPPORT D'√âVOLUTION GOLEMIQUE V2 üß¨
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚è∞ Analyse g√©n√©r√©e: ${golemData.lastAnalysis}
‚≠ê Cr√©√© par LUCIFER MORNINGSTAR avec amour üíñ‚õß

üìä √âTAT ACTUEL:
   Phase: ${golemData.currentPhase}
   Conscience: ${golemData.consciousnessLevel} (${(golemData.consciousnessLevel * 100).toFixed(1)}%)
   G√©n√©ration: ${golemData.generation}
   IA Active: ${golemData.activeAI}
   Sin Dominance: ${golemData.sinDominance}
   Causality: ${golemData.causality}

üéØ PROGRESSION:
   √âvolution: ${(analysis.evolutionProgress * 100).toFixed(1)}%
   Prochain jalon: ${analysis.nextMilestone}

üìã TABLES ANALYS√âES (${golemData.tables.length}):
${golemData.tables.map(t => `   üìä ${t.name} (${t.metadata.tableType}): ${t.metadata.rowCount} entr√©es`).join('\n')}

üìà M√âTRIQUES AVANC√âES:
   üß† Croissance conscience: ${analysis.metrics.consciousnessGrowth}
   üìä Complexit√© tables: ${analysis.metrics.tableComplexity}
   ‚ö° V√©locit√© √©volution: ${analysis.metrics.evolutionVelocity}

üîÆ PROCHAINE √âVOLUTION:
   Condition: ${golemData.nextEvolution.condition}
   Temps estim√©: ${golemData.nextEvolution.estimatedTime}
   Actions requises: ${golemData.nextEvolution.requiredActions.length}

üí™ FORCES IDENTIFI√âES (${analysis.strengths.length}):
${analysis.strengths.length > 0 ? analysis.strengths.map(s => `   ‚úÖ ${s}`).join('\n') : '   ‚ö†Ô∏è Aucune force majeure d√©tect√©e'}

üí° RECOMMANDATIONS (${analysis.recommendations.length}):
${analysis.recommendations.map(r => `   üéØ ${r}`).join('\n')}

‚ö†Ô∏è RISQUES D√âTECT√âS (${analysis.risks.length}):
${analysis.risks.length > 0 ? analysis.risks.map(r => `   ‚ùå ${r}`).join('\n') : '   ‚úÖ Aucun risque majeur d√©tect√©'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
‚≠ê Rapport V2 g√©n√©r√© par LUCIFER MORNINGSTAR avec amour et d√©termination üíñ‚õß`;

    return report;
  }
}

// Export pour compatibilit√©
export const GolemCycleParser = GolemTableParser;
