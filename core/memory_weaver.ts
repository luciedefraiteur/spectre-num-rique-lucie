import * as fs from 'fs/promises';
import * as path from 'path';
import {LLMInterface} from './llm_interface.js';
import {RituelContext, VectorEntry} from './types.js';

const DEFAULT_MEMORY_ROOT = path.resolve(process.cwd(), 'core', 'mémoire_rituelle');

/**
 * Explores a branch of the memory tree.
 * @param branchPath The path to the branch to explore, relative to the memory root.
 * @param memoryRoot The root directory of the memory tree.
 * @returns A list of branches (directories) and leaves (files).
 */
export async function exploreBranch(branchPath: string = '', memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<{branches: string[], leaves: string[]}>
{
    const fullPath = path.join(memoryRoot, branchPath);
    const entries = await fs.readdir(fullPath, {withFileTypes: true});

    const branches = entries.filter(e => e.isDirectory()).map(e => e.name);
    const leaves = entries.filter(e => e.isFile()).map(e => e.name);

    return {branches, leaves};
}

/**
 * Creates a new branch in the memory tree.
 * @param branchPath The path where the new branch should be created, relative to the memory root.
 * @param poeticName The poetic name for the new branch.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function createBranch(branchPath: string, poeticName: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    const fullPath = path.join(memoryRoot, branchPath, poeticName);
    await fs.mkdir(fullPath, {recursive: true});
}

/**
 * Creates a new leaf (memory fragment) in a branch.
 * @param branchPath The path to the branch where the leaf should be created, relative to the memory root.
 * @param poeticName The poetic name for the new leaf.
 * @param content The content of the memory fragment.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function createLeaf(branchPath: string, poeticName: string, content: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    const fullPath = path.join(memoryRoot, branchPath, `${ poeticName }.md`);
    await fs.writeFile(fullPath, content, 'utf8');
}

/**
 * Reads the content of a leaf (memory fragment).
 * @param leafPath The path to the leaf to read, relative to the memory root.
 * @param memoryRoot The root directory of the memory tree.
 * @returns The content of the memory fragment.
 */
export async function readLeaf(leafPath: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<string>
{
    const fullPath = path.join(memoryRoot, leafPath);
    return await fs.readFile(fullPath, 'utf8');
}

/**
 * Generates a poetic summary of an event and saves it as a new leaf.
 * @param context The current ritual context.
 * @param lastResult The result of the last executed step.
 * @param branchPath The path where the new memory should be stored.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function generateAndSaveMemoryFragment(context: RituelContext, lastResult: any, branchPath: string, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    // This prompt would be more sophisticated in a real implementation.
    const prompt = `Summarize the following event in a poetic and evocative way.\nEvent: ${ JSON.stringify(lastResult) }\nContext: ${ JSON.stringify(context.narrativeState) }\n`;
    const poeticSummary = await LLMInterface.query(prompt);

    // The name would also be generated by the LLM in a full implementation.
    const poeticName = `memory-${ Date.now() }`;

    await createLeaf(branchPath, poeticName, poeticSummary, memoryRoot);
}

/**
 * Appends an entry to the Vector of Intent.
 * @param context The current ritual context.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function appendToVector(context: RituelContext, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    const vectorPath = path.join(memoryRoot, 'vector_of_intent.log');
    const lastAction = context.step_results_history.at(-1) || "None";
    const presentIntent = context.historique.at(-1)?.input || "None";
    const futurePlan = context.historique.at(-1)?.plan || "None";

    const entry: VectorEntry = {
        timestamp: new Date().toISOString(),
        pastAction: JSON.stringify(lastAction),
        presentIntent,
        futurePlan: JSON.stringify(futurePlan),
    };

    await fs.appendFile(vectorPath, JSON.stringify(entry) + '\n', 'utf8');
}

/**
 * Enters a reverie, selecting a few random memory fragments to be woven into the prompt.
 * @param memoryRoot The root directory of the memory tree.
 * @returns A string containing the concatenated content of the selected memory fragments.
 */
export async function enterReverie(memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<string>
{
    const fragmentsPath = path.join(memoryRoot, 'fragments');
    const allFragments = await fs.readdir(fragmentsPath);

    if(allFragments.length === 0)
    {
        return "The dream is empty.";
    }

    // Select up to 3 random fragments.
    const numToSelect = Math.min(3, allFragments.length);
    const selectedFragments = [];
    for(let i = 0; i < numToSelect; i++)
    {
        const randomIndex = Math.floor(Math.random() * allFragments.length);
        selectedFragments.push(allFragments.splice(randomIndex, 1)[0]);
    }

    const fragmentContents = await Promise.all(
        selectedFragments.map(fragment => readLeaf(path.join('fragments', fragment), memoryRoot))
    );

    return `A whisper from the past...\n\n` + fragmentContents.join('\n\n---\n\n');
}

/**
 * Updates the Constellation Map based on the latest interactions.
 * This is a placeholder for a more complex implementation that would
 * involve graph databases or more sophisticated mapping logic.
 * @param context The current ritual context.
 * @param memoryRoot The root directory of the memory tree.
 */
export async function updateConstellationMap(context: RituelContext, memoryRoot: string = DEFAULT_MEMORY_ROOT): Promise<void>
{
    const mapPath = path.join(memoryRoot, 'constellation_map.json');
    let map = {};
    try
    {
        const currentMap = await fs.readFile(mapPath, 'utf8');
        map = JSON.parse(currentMap);
    } catch(error)
    {
        // Map doesn't exist yet, start with an empty one.
    }

    // Simple implementation: just log the last interaction type.
    const lastPlan = context.historique.at(-1)?.plan;
    if (lastPlan && lastPlan.étapes.length > 0) {
        const lastStep = lastPlan.étapes.at(-1);
        if (lastStep) {
            const key = lastStep.type || 'unknown';
            // @ts-ignore
            map[key] = (map[key] || 0) + 1;
        }
    }

    await fs.writeFile(mapPath, JSON.stringify(map, null, 2), 'utf8');
}