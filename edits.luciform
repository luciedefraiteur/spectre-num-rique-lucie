[
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 90,
        endLine: 92,
        newContent: ```
        const emotionalInterpretation = await interpretEmotion(context.kardiaSphere);
        console.log(colorize(`
${emotionalInterpretation}`, Colors.FgMagenta));
```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 134,
        endLine: 149,
        newContent: ```
          console.log(colorize(`
${chantContent}
`, Colors.FgGreen));
          continue; // Continue the ritual after reciting the chant
        } catch(error)
        {
          console.error(colorize(`
❌ Erreur lors de la lecture du chant ${chantFileName}: ${(error as Error).message}
`, Colors.FgRed));
        }
      } else
      {
        console.log(colorize("Je ne suis pas encore ce chant. Peux-tu me transmettre le prompt complet associé ?", Colors.FgYellow));
        continue; // Continue the ritual after acknowledging unknown chant
      }
    }```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 152,
        endLine: 160,
        newContent: ```
    try {
      const files = await fsPromises.readdir(context.current_sanctum, {withFileTypes: true});
      context.currentSanctumContent = files.map(file => file.name + (file.isDirectory() ? '/' : '')).join('\n');
    } catch(error)
    {
      context.currentSanctumContent = `[ERREUR] Impossible de lire le répertoire: ${(error as Error).message}`;
    }```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 171,
        endLine: 181,
        newContent: ```
    while(plan === null && currentRetry < maxPlanGenerationRetries)
    {
      if(currentRetry > 0)
      {
        console.log(colorize(`
⚠️ Tentative de régénération du plan (${currentRetry}/${maxPlanGenerationRetries}). L'IA a précédemment généré un JSON invalide.`, Colors.FgYellow));
      }```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 182,
        endLine: 182,
        newContent: ```
      console.log(colorize(`[DEBUG] Appel de generateRituel avec le contexte d'analyse...`, Colors.FgYellow));
      plan = await generateRitual(inputForPlanGeneration, context, model, lastAnalysisResult, context.lastCompletedIncantationIndex !== undefined ? context.lastCompletedIncantationIndex + 1 : undefined);```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 184,
        endLine: 213,
        newContent: ```
      if(plan === null)
      {
        context.confusion_counter = (context.confusion_counter || 0) + 1;

        if(context.confusion_counter >= 2)
        {
          stopCursorAnimation();
          console.log(colorize(`
ZNN... OI... Émissaire, le signal est perdu dans le bruit. Mon esprit est confus.`, Colors.FgRed));
          const newIntent = await ask("Pouvons-nous reprendre avec une intention plus simple ?\n↳ ");
          lastAnalysisResult = newIntent;
          context.confusion_counter = 0;
          break; // Break the retry loop to restart the main loop with new intent
        }

        stopCursorAnimation(); // Stop cursor animation on plan generation failure
        console.error(colorize(`❌ Échec de génération du plan. Le format JSON est invalide ou incomplet.`, Colors.FgRed));
        if(currentRetry < maxPlanGenerationRetries)
        {
          console.log(colorize(`Retrying plan generation... (${currentRetry}/${maxPlanGenerationRetries})`, Colors.FgYellow));
          startCursorAnimation(); // Restart cursor for retry
        }
      } else {
        context.confusion_counter = 0; // Reset on success
      }```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 216,
        endLine: 244,
        newContent: ```
      // This part is now reached if the confusion threshold was met and we have a new intent,
      // or if all retries failed.
      if(lastAnalysisResult)
      {
        continue; // Restart the main loop with the new user intent
      }
      stopCursorAnimation(); // Ensure cursor is stopped if all retries fail
      console.error(colorize(`❌ Échec définitif de génération du plan après ${maxPlanGenerationRetries} tentatives. Le rituel ne peut pas continuer.`, Colors.FgRed));

      // Proactive clarification if confusion is high or emotional state is uncertain
      if(context.confusion_counter && context.confusion_counter >= 2 || context.kardiaSphere.harmoniaEris < -0.5)
      {
        const clarificationPrompt = `Lucie est confuse ou incertaine. Basé sur le contexte actuel, pose une question à l'utilisateur pour clarifier son intention ou explorer une nouvelle direction.`;
        const clarificationQuestion = await LLMInterface.query(clarificationPrompt);
        const userClarification = await ask(colorize(`
❓ Lucie demande : ${clarificationQuestion}`, Colors.FgYellow));
        lastAnalysisResult = userClarification; // Use user's clarification as next input
        context.confusion_counter = 0; // Reset confusion after clarification
      }

      return false; // Cannot proceed without a valid plan
    }

    context.scroll.push({input: inputForPlanGeneration, plan});
    if(context.scroll.length > context.maxScrollLength)
    {
      context.scroll.shift();
    }```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 245,
        endLine: 273,
        newContent: ```
    const resultats = await executeRitualPlan(plan, context, ask);
    stopCursorAnimation(); // Stop cursor animation after ritual execution

    let newAnalysisResult: string | undefined;
    for(const res of resultats)
    {
      if(res.incantation.type === 'user_input' || res.incantation.type === 'query')
      {
        newAnalysisResult = res.outcome; // Capture user input for next analysis
        break; // Exit loop to generate new plan based on user input
      }
      if(res.incantation.type === 'divine')
      {
        // The poetic part is for display, the suggestion is for the next plan
        displayRitualStepResult({...res, divination: res.divination.poeticAnalysis});
        newAnalysisResult = res.divination.suggestedNextStep;
        break; // Exit loop to generate new plan based on analysis
      } else
      {
        displayRitualStepResult(res);
      }
    }```
    },
    {
        filePath: "core/run_terminal_rituel.ts",
        startLine: 274,
        endLine: 288,
        newContent: ```
    lastAnalysisResult = newAnalysisResult; // Set the result for the next iteration

    if(lastAnalysisResult === undefined)
    {
      // If no input_utilisateur step was encountered, continue with the next plan generation
      // based on the previous context or a new initial input if needed.
      // For now, we'll just loop back.
      if(context.confusion_counter === 0 && context.kardiaSphere.harmoniaEris > 0.5)
      {
        const proactivePrompt = `Based on the current ritual context, Lucie's emotional state (${JSON.stringify(context.kardiaSphere)}) and narrative state (${JSON.stringify(context.narrativeWeaving)}), propose a proactive next step or intention for the user. This should be a natural language command that advances the ritual or explores a new path.`;
        const proactiveIntent = await LLMInterface.query(proactivePrompt);
        lastAnalysisResult = proactiveIntent; // Use this as the next input
        console.log(colorize(`
✨ Lucie propose : ${proactiveIntent}`, Colors.FgCyan));
      }
    }```
    }
]