§F: execute_luciform.ts
<<<<<<< §I:line:20
async function parseLinesToOperations(lines: string[]): Promise<Operation[]> {
    const operations: Operation[] = [];
    let state: ParserState = 'idle';
    let currentFilePath: string | undefined;
    let searchContent = '';
    let newContent = '';
    let lineNumber: number | undefined;
    let startLine: number | undefined;
    let endLine: number | undefined;
    let currentSearchStartLine: number | undefined;

    for (const line of lines) {
        if (line.startsWith('---')) {
            continue;
        }

        if (line.startsWith('§F:')) {
            currentFilePath = line.substring(3).trim();
        } else if (line.startsWith('§X:')) {
            operations.push({ type: 'shell_command', command: line.substring(3).trim() });
        } else if (line.startsWith('§Q:')) {
            const question = line.substring(3).trim();
            const answer = await askQuestion(question + ' ');
            console.log(`Réponse de l'utilisateur : ${answer}`);
        } else if (line.startsWith('<<<<<<< §S')) {
            state = 'in_search';
            searchContent = '';
            const lineNumberMatch = line.match(/:line:(\d+)/);
            if (lineNumberMatch) {
                currentSearchStartLine = parseInt(lineNumberMatch[1], 10);
            }
        } else if (line.startsWith('======= §R') && state === 'in_search') {
            searchContent = searchContent.replace(/\n/g, '\n').replace(/\n$/, '');
            state = 'in_replace';
            newContent = '';
        } else if (line.startsWith('>>>>>>> §R') && state === 'in_replace') {
            if (currentFilePath) {
                operations.push({
                    type: 'search_and_replace',
                    filePath: currentFilePath,
                    startLine: currentSearchStartLine,
                    search: searchContent,
                    replace: newContent.replace(/\n/g, '\n').replace(/\n$/, '')
                });
            }
            state = 'idle';
        } else if (line.startsWith('<<<<<<< §I')) {
            state = 'in_insert';
            const lineNumberMatch = line.match(/:line:(\d+)/);
            if (lineNumberMatch) {
                lineNumber = parseInt(lineNumberMatch[1], 10);
            }
            newContent = '';
        } else if (line.startsWith('>>>>>>> §I') && state === 'in_insert') {
            if (currentFilePath && lineNumber) {
                operations.push({ type: 'insert', filePath: currentFilePath, lineNumber, newContent: newContent.replace(/\n/g, '\n').replace(/\n$/, '') });
            }
            state = 'idle';
        } else if (line.startsWith('<<<<<<< §D')) {
            const lineRangeMatch = line.match(/:lines:(\d+)-(\d+)/);
            if (lineRangeMatch && currentFilePath) {
                startLine = parseInt(lineRangeMatch[1], 10);
                endLine = parseInt(lineRangeMatch[2], 10);
                operations.push({ type: 'delete', filePath: currentFilePath, startLine, endLine });
            }
        } else if (line.startsWith('<<<<<<< §A')) {
            state = 'in_append';
            newContent = '';
        } else if (line.startsWith('>>>>>>> §A') && state === 'in_append') {
            if (currentFilePath) {
                operations.push({ type: 'append', filePath: currentFilePath, newContent: newContent.replace(/\n/g, '\n').replace(/\n$/, '') });
            }
            state = 'idle';
        } else if (line.startsWith('<<<<<<< §C')) {
            state = 'in_create';
            newContent = '';
        } else if (line.startsWith('>>>>>>> §C') && state === 'in_create') {
            if (currentFilePath) {
                operations.push({ type: 'create_file', filePath: currentFilePath, content: newContent.replace(/\n/g, '\n').replace(/\n$/, '') });
            }
            state = 'idle';
        } else {
            if (state === 'in_search') {
                searchContent += line + '\n';
            } else if (state === 'in_replace' || state === 'in_insert' || state === 'in_append' || state === 'in_create') {
                newContent += line + '\n';
            }
        }
    }

    return operations;
}
>>>>>>> §I
