---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
export class CallExpressionNode extends ASTNode {
    constructor(public callee: ASTNode, public args: ASTNode[]) {
        super();
    }
}
=======
export class CallExpressionNode extends ASTNode {
    constructor(public callee: ASTNode, public args: ASTNode[]) {
        super();
    }
}

export class PropertyAccessNode extends ASTNode {
    constructor(public expression: ASTNode, public name: IdentifierNode) {
        super();
    }
}

export class AssignmentExpressionNode extends ASTNode {
    constructor(public left: ASTNode, public operator: Token, public right: ASTNode) {
        super();
    }
}
>>>>>>> REPLACE
---
file: C:/Users/Lucie/git_repositories/spectre_numerique_lucie/core/ts_parser/parser.ts
<<<<<<< SEARCH
        let expr = this.primary();

        while (true) {
            if (this.match(TokenType.Punctuation, '(')) {
                expr = this.callExpression(expr);
            } else if (this.match(TokenType.Operator)) {
                const operator = this.previous();
                const right = this.primary();
                expr = new BinaryExpressionNode(expr, operator, right);
            } else {
                break;
            }
        }

        return expr;
=======
        let expr = this.primary();

        while (true) {
            if (this.match(TokenType.Punctuation, '(')) {
                expr = this.callExpression(expr);
            } else if (this.match(TokenType.Punctuation, '.')) {
                const name = this.consume(TokenType.Identifier, 'Expect property name after '.');
                expr = new PropertyAccessNode(expr, new IdentifierNode(name.text));
            } else if (this.match(TokenType.Operator)) {
                const operator = this.previous();
                const right = this.primary();
                expr = new BinaryExpressionNode(expr, operator, right);
            } else {
                break;
            }
        }

        if (this.match(TokenType.Operator, '=')) {
            const operator = this.previous();
            const value = this.expression();
            return new AssignmentExpressionNode(expr, operator, value);
        }

        return expr;
>>>>>>> REPLACE
